# 061.缓存使用与问题

## 1. 缓存失效

### 1.1 缓存穿透

- 缓存穿透是指缓存和==数据库中都没有的数据==，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
- 解决：缓存空对象、布隆过滤器、mvc拦截器

### 1.2 缓存雪崩

- 缓存雪崩是指在我们设置缓存时key采用了相同的过期时间，导致==缓存在某一时刻同时失效==，请求全部转发到DB，DB瞬时压力过重雪崩。

- 解决方案：

- 规避雪崩：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
  如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中。
  设置热点数据永远不过期。
  出现雪崩：降级 熔断
  事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
  事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
  事后：利用 redis 持久化机制保存的数据尽快恢复缓存

### 1.3 缓存击穿

- 缓存雪崩和缓存击穿不同的是：

- ==缓存击穿 指 并发查同一条数据==。缓存击穿是指==缓存中没有但数据库中有的数据==（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
  缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
- 解决方案：
- 设置热点数据永远不过期。
  加互斥锁：业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db去数据库加载，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。

## 2.分布式缓存

* 加锁-原子性
* 删锁-原子性
* 分布式项目时，但本地锁只能锁住当前服务，需要分布式锁
* redis分布式锁的原理：setnx，同一时刻只能设置成功一个
* 前提，锁的key是一定的，value可以变
* 没获取到锁阻塞或者sleep一会
* 设置好了锁，玩意服务出现宕机，没有执行删除锁逻辑，这就造成了死锁
  * 解决：设置过期时间
* 业务还没执行完锁就过期了，别人拿到锁，自己执行完去删了别人的锁
  * 解决：锁续期（redisson有看门狗），。删锁的时候明确是自己的锁。如uuid
* 判断uuid对了，但是将要删除的时候锁过期了，别人设置了新值，那删除了别人的锁
  * 解决：删除锁必须保证原子性（保证判断和删锁是原子的）。使用redis+Lua脚本完成，脚本是原子的
    
* ![image-20210424155925096](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210424155925096.png)
* ![image-20210424170321138](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210424170321138.png)
* 