# 080.商城业务-分布式事务

https://blog.csdn.net/hancoder/article/details/114983771

![image-20210514162213513](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210514162213513.png)

## 1. 本地事务

注意**同类中调用**的话，被调用事务会**失效**，原因在于aop。事务基于代理，同对象的方法动态代理都是同一个。解决方案是使用代理对象调用。引用`aop-starter`后，使用`aspectJ`，开启`AspectJ`动态代理，原来默认使用的是jdk动态代理。

使用 `@EnableAspectJAutoProxy(exposeProxy=true) `后，就取代了jdk动态代理。它没有接口也可以创建动态代理。设置true是为了对外暴露代理对象。
`AopContext.currentProxy()` 然后强转，就是当前代理对象。

```java
public interface AService {  
    public void a();  
    public void b();  
}  

@Service()  
public class AServiceImpl1 implements AService{  
    @Transactional(propagation = Propagation.REQUIRED)  
    public void a() {  
        this.b();  
    }  
    @Transactional(propagation = Propagation.REQUIRES_NEW)  
    public void b() {  
    }  
} 

此处的this指向目标对象，因此调用this.b()将不会执行b事务切面，即不会执行事务增强，
    因此b方法的事务定义“@Transactional(propagation = Propagation.REQUIRES_NEW)”将不会实施，
    即结果是b和a方法的事务定义是一样的（我们可以看到事务切面只对a方法进行了事务增强，没有对b方法进行增强）
    
    
Q1：b中的事务会不会生效？
A1：不会，a的事务会生效，b中不会有事务，因为a中调用b属于内部调用，没有通过代理，所以不会有事务产生。
Q2：如果想要b中有事务存在，要如何做？
A2：<aop:aspectj-autoproxy expose-proxy=“true”> ，设置expose-proxy属性为true，将代理暴露出来，使用AopContext.currentProxy()获取当前代理，将this.b()改为((UserService)AopContext.currentProxy()).b()
```

* 解决方案

```java
public void a() {  
    ((AService) AopContext.currentProxy()).b();//即调用AOP代理对象的b方法即可执行事务切面进行事务增强  
} 
```



## 2. 分布式事务

* 远程服务成功，由于网络故障没有返回
* 本地服务收到异常，事务回滚，但其实远程服务已经成功（**库存已经扣除，订单没有创建**）
* `@Transactional`：只能操作本地事务
  * `isolation = REPEATABLE_READ`：可重复读（默认级别）



## 3. CAP理论

- CAP原则又称CAP定理，指的是在一个分布式系统中

- 一致性（consistency）
  - 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
- 可用性（Availability）
  - 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
- 分区容惜性（Partition tolerance）
  - 大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区(partition)。
    分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。
  - CAP原则指的是，这三个要素最多只能同时实现两点，**不可能三者兼顾**

- CP要求一致性（有一个没同步好就不可用）
- AP要求高可用



## 4. BASE理论

- 后续发现扣减不一致后，再恢复

- BASE理论是对CAP理论的延伸，思想是即使无法做到强一致性（CAP的一致性就是强一致性），但可以采用弱一致性，即最终一致性


BASE是指：

- 基本可用(BasicallyAvailable)
  基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。
  - 响应时间上的损失：正常情况下搜索引擎需要在0．5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1～2秒。
  - 功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。
- 软状态（soft state）
  - 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。
- 最终一致性（Eventual Consistency）
  - 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。（这也是分布式事务的想法）

从客户端角度，多进程并发访同时，更新过的数据在不同程如何获的不同策珞，决定了不同的一致性。

- 对于关系型要求更新过据能后续的访同都能看到，这是强一致性。
- 如果能容忍后经部分过者全部访问不到，则是弱一致性
- 如果经过一段时间后要求能访问到更新后的数据，则是最终一致性



## 5. 分布式事务几种方案

### 1) 2PC模式(XA事务)

- 数据库支持的2pc【2二阶段提交】，又叫做XA Transactions
- 支持情况：mysql从5．5版本开始支持，SQLserver2005开始支持，Oracle7开始支持。

- 其中，XA是一个两阶段提交协议，该协议分为以下两个阶段：
  - 第一阶段：事务协调器要求每个涉及到事务的数据库预提交（P090此操作，并反映是否可以提交，
  - 第二阶段：事务协调器要求每个数据库提交数据。
  - 其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息
- ![image-20210515170505142](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210515170505142.png)

- 如图所示，如果有订单服务和库存服务要求分布式事务，要求有一个总的事务管理器

- 总的事务管理让事务分为两个阶段，
  - 第一个阶段是预备（log）。
  - 第二个阶段是正式提交（commit）
    总事务管理器接收到两个服务都预备好了log（收到ack），就告诉他们commit
- 如果有一个没准备好，就回滚所有人。

- 总结2PC：
  - XA协议比较简单，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。
  - 性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景
  - XA目前在商业数据库支持的比较理想，在mysql数据库中支持的不太理想，mysql的XA实现，没有记录阶段日志，主备切换回导致主库与备库数据不一致。
  - 许多nosql没有支持XA，这让XA的应用场景变得非常狭隘。
  - 也有3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）



### 2) 柔性事务-TCC事务补偿型方案

- 刚性事务：遵循ACID原则，强一致性。
- 柔性事务：遵循BASE理论，最终一致性；

与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。

- 一阶段 prepare 行为：调用自定义的prepare逻辑。
- 二阶段 commit 行为：调用自定义的commit逻憬。
- 二阶段 rollback 行为：调用自定义的rollback逻辑。
- 所谓TCC模式，是指支持 自定义的 分支事务纳入到全局事务的管理中。



### 3）柔性事务-最大努力通知型方案

- 按规律进行通知，不保证数据一定能通知成功，但会提供可查询操作接囗进行核对。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送就请求，设置最大通知次数。达到通知次数后即不再通知。

- 案例：银行涌知、商户通知等（各大交易业务平台间的商户涌知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调



### 4）柔性事务=可靠消息+最终一致性方案（异步确保型）

- 实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送捎息，实时捎息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。



## 6. seata解决分布式事务问题













